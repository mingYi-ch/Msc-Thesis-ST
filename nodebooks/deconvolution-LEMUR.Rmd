---
title: "Deconvolution"
output:
  html_document:
    df_print: paged
output.width: "75%"
---

# Library

```{r}
library(SpatialExperiment)
library(Matrix)
library(STdeconvolve)
library(ggplot2)
library(gghighlight)
library(rlang)

library(lemur)
library(tidyverse)

library(igraph)

```

# Load data

```{r}
set.seed(5)
```

```{r}
data_dir <- '/shares/rheumatologie.usz/caroline/spatial'
fn <- list.files(data_dir)  # 5  biopsies

biopsy_dirs <- character(0)
biopsy_names <- character(0)

for (name in fn) {
  path <- paste(data_dir, name, sep = '/')
  biopsy_dirs <- c(biopsy_dirs, path)
  
  file_path <-  paste(path, "filtered_feature_bc_matrix.h5", sep = '/')
  if (!file.exists(file_path)) {
    path <-  paste(path, "outs", sep = '/')
  }
    
  biopsy_names <- c(biopsy_names, name)
  
}
names(biopsy_dirs) <-  biopsy_names

biopsy_names
biopsy_dirs
# print(object.size(biopsy_objs), units = 'Mb')

```

```{r}
## directory structure does not match
# dir <-  biopsy_dirs[["SHK166_RA_Knee"]]
# obj_path <- paste(dir, 'filtered_feature_bc_matrix', sep = '/')
# obj_path
# se <- SpatialExperiment::read10xVisium(samples = dir,
#      type = "sparse",
#      data = "filtered")
```

```{r}
dir <-  biopsy_dirs[["SHK166_RA_Knee"]]

path.pos <- paste(dir, 'spatial/tissue_positions.csv', sep = '/')
pos.info <- read.csv(path.pos)
head(pos.info)
# Filting
pos.info <- subset(pos.info, in_tissue == 1)
pos <- pos.info[, c('pxl_row_in_fullres', 'pxl_col_in_fullres')]
dim(pos)
rownames(pos) <- pos.info$barcode
plot(pos)

path.gexp <- paste(dir, 'filtered_feature_bc_matrix/matrix.mtx.gz', sep = '/')

gexp <- Matrix::readMM(path.gexp)
dim(gexp)
gexp[1:5,1:5]

path.bc <- paste(dir, 'filtered_feature_bc_matrix/barcodes.tsv.gz', sep = '/')
barcodes <- read.csv(path.bc, sep="\t", header=FALSE)
head(barcodes)
dim(barcodes)
colnames(gexp) <- barcodes$V1

names(barcodes)

path.feature <- paste(dir, 'filtered_feature_bc_matrix/features.tsv.gz', sep = '/')
features <- read.csv(path.feature, sep="\t", header=FALSE)
dim(features)
rownames(gexp) <- features$V2
```

```{r}
pos <- as.matrix(pos)
# "pxl_col_in_fullres" = "y" coordinates, and "pxl_row_in_fullres" = "x" coordinates
colnames(pos) <- c("x", "y")

se <- SpatialExperiment(
    assay = gexp, 
    spatialCoords = pos)

assayNames(se) <- 'counts'


se
```

# Deconvolve

## Quality control

```{r}
cd <- assay(se, "counts")

# Filter out poor pixels and genes
counts <- cleanCounts(cd, min.lib.size = 100, min.reads = 10, verbose = TRUE)
dim(counts)
dim(pos)

# Log transform

```

## STDeconvolve

```{r}
# Select features
corpus <- restrictCorpus(counts, 
                         removeAbove=0.95, 
                         removeBelow = 0.05, 
                         nTopOD = NA,
                         plot = FALSE,
                         alpha = 0.05) # 1e-8

ldas <- fitLDA(t(as.matrix(corpus)), Ks = 8:20)

```

```{r}
opt.K <- 10
# select the LDA model of interest and get the beta (cell-type transcriptional profiles) and theta (cell-type barcode proportions) matrices.
optLDA <- optimalModel(models = ldas, opt = opt.K)
results <- getBetaTheta(optLDA, perc.filt = 0.05, betaScale = 1000)
deconProp <- results$theta
deconGexp <- results$beta
```

```{r}
## visualize deconvolved cell-type proportions
vizAllTopics(deconProp, pos[rownames(deconProp),], r=55, lwd=0)	  

## interpret these cell-types based on their gene expression
topGenes(deconGexp)
## top genes based on log 2 (fold change) for each cell-type
lapply(1:opt.K, function(i) {
  head(sort(log2(deconGexp[i,]/colMeans(deconGexp[-i,])), decreasing=TRUE))
})
```

```{r}
lapply(1:opt.K, function(i) {
vizTopic(theta = deconProp, pos = pos, topic = i, plotTitle = i,
         size = 1, stroke = 0, alpha = 0.5,
         low = "white",
         high = "red")
})
```

## Annotation strategy

# Define covariate

## Proximity to a specific cell type

```{r}
# each point has at most 8 neighbours, return row idxs of neighbours including itself
get.adjacency.matrix <- function(coords) {
  dim.bc <- dim(coords)[1]
  adjacency.matrix <-  matrix(0, nrow = dim.bc, ncol = dim.bc)
  
  for (idx.1 in 1:dim.bc) {
    for (idx.2 in seq2(idx.1 + 1, dim.bc)) {
      
    }
      x1 <- coords[idx.1, ][1]
      y1 <- coords[idx.1, ][2]
      
      x2 <- coords[idx.2, ][1]
      y2 <- coords[idx.2, ][2]
      
      nei.diff <- c(-1, 0, 1)
      is.nei <- (x1 - x2 %in% nei.diff) && (y1 - y2 %in% nei.diff)
      if (is.nei) {
          adjacency.matrix[idx.1, idx.2] <- 1
          adjacency.matrix[idx.2, idx.1] <- 1
      }
  }
  return(adjacency.matrix)
}

pos <- spatialCoords(se)
adjacency.matrix <- get.adjacency.matrix(pos)
sum(adjacency.matrix)

```

```{r}
# build a graph
g <- graph_from_adjacency_matrix(adjacency.matrix, mode = 'undirected')
bc.idxs <- seq.int(nrow(pos))

target.idxs <- which(rownames(pos) %in% rownames(pos.target))
target.idxs

# find shortest dist
spl <- c()

for (i in bc.idxs) {
  spl.i <- numeric()
  
  for (j in target.idxs) {
    shortest_path <- shortest_paths(g, from = i, to = j, output = "vpath")
    vpath <- shortest_path$vpath 
    
    if (is.null(vpath)) {
      cnt.v <- Inf
    }else{
      cnt.v <- length(vpath[[1]]) - 1
    }
    spl.i <- c(spl.i, cnt.v)
  }
  spl <- rbind(spl, spl.i)
}
```

```{r}
# Define target cell types
topic.target <- "9"
prop.threshold <- 0.2 # 
weight <- NULL

pos <- spatialCoords(se)


dim(deconProp)
dim(deconGexp)

heatmap(deconGexp)
colnames(deconProp)
deconProp_target <- deconProp[deconProp[,topic.target] > prop.threshold,]

dim(deconProp_target)
bc_target <- rownames(deconProp_target)
pos.target <-  pos[bc_target,]

# Calculate min dist: use graph later, not connected
pos.target[,"y"] <- -1 * pos.target[,"y"]
dists <-abs(pos %*% t(pos.target))
dists.min <- rowMins(dists)
names(dists.min) <- rownames(dists)

se$dists.min <- dists.min
se
```

```{r}
# some spots are filled out by quality control
pos <- pos[rownames(deconProp),]

as_tibble(pos) %>%
  mutate(bc = rownames(pos)) %>%
  ggplot(aes(x = x, y = y)) +
    geom_point(size = 1, color = "grey") +
    gghighlight(bc %in% rownames(pos.target)) +
    geom_point(col = "blue", size = 1) +
    labs(title = paste0("Topic - ", topic.target), x = "pxl_row_in_fullres", y = "pxl_col_in_fullres")

as_tibble(pos) %>%
  mutate(prop = deconProp[, topic.target]) %>%
  ggplot(aes(x = x, y = y)) +
    geom_point(aes(color = prop), size = 1, stroke = 0) +
    scale_color_gradient2()
```

# LEMUR

```{r}
fit <- lemur(se, design = ~ min.dist, n_embedding = 30, test_fraction = 0.5)
fit
# fit <- test_de(fit, contrast = cond())

```

# Misc

```{r}
x <- 1:2
y <- 3:7

combinations <- expand.grid(x,y)
as.list(combinations)

nei.diff <- c(-1, 0, 1)
9 - 8 %in% nei.diff
for (i in 9:8){
  print(i)
}

a <- 5
b <- 1

for (i in a:b) {
  print(i)
}
# Output: (No output because a > b)
seq_len(9,8)
seq_len()
NA - 1
min(NA, 1)


```

```{r}
# Create a simple unweighted graph
# Example edge list
edges <- data.frame(from = c(0, 1, 1, 2), to = c(1, 2, 3, 3))

# Create a graph from the edge list
graph <- graph.data.frame(edges, directed = FALSE)  # Adjust 'directed' as needed


# Specify source and target vertices
source <- 1
target <- 3

# Find the shortest path
shortest_paths <- shortest_paths(graph, from = source, to = target)
shortest_paths$vpath
# Check if a path exists
if (length(shortest_paths) > 0) {
    # Access the first shortest path (modify as needed)
    shortest_path <- shortest_paths[[1]]

    cat("Shortest path:", shortest_path)
} else {
    cat("No path exists between", source, "and", target)
}


```

```{r}
path <- "/shares/rheumatologie.usz/caroline/spatial/SHK166_RA_Knee/deconvolution/deconvolution_k10/deconvolution_topic_features_k10.csv"
deconvolution_topic_features_k10 <- read.csv(path)
head(deconvolution_topic_features_k10)
colnames(deconvolution_topic_features_k10)

path <- "/shares/rheumatologie.usz/caroline/spatial/SHK166_RA_Knee/deconvolution/deconvolution_k10/deconvolved_spots_k10.csv"
deconvolved_spots_k10 <- read.csv(path)
head(deconvolved_spots_k10)
```

```{r}
# Create a matrix (you can replace this with your own data)
my_matrix <- matrix(c(1, 2, 3, 4, 5, 6, 3, 3, -Inf), ncol = 3)

# Calculate row minimums, ignoring NA values
row_mins <- rowMins(my_matrix, na.rm = TRUE)

# Print the result
print(row_mins)

```

# Reference

-   Tutorial from Prof. Jean Fan, <https://jef.works/blog/2023/05/29/stdeconvolve-breast-cancer/>

-   STdeconvolve Vignettes, <https://www.bioconductor.org/packages/release/bioc/vignettes/STdeconvolve/inst/doc/vignette.html#spatialexperiment-inputs>
