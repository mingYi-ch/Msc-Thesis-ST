---
title: "Deconvolution"
output:
  html_document:
    df_print: paged
output.width: "75%"
---

# Library

```{r}
library(Matrix)
library(ggplot2)
library(gghighlight)
library(tidyverse)

library(STdeconvolve)
library(SpatialExperiment)
library(lemur)
library(igraph)
library(qs)
library(plotrix)

```

```{r}
source("../src/util.R")
```

# Load data

```{r}
set.seed(5)
```

```{r}
# path for S3IT
data_dir <- '/shares/rheumatologie.usz/caroline/spatial'
# path for local
data_dir <- '../data'

biopsy_dirs <- get.dirs(data_dir)
```

```{r}
dir <-  biopsy_dirs[["SHK166_RA_Knee"]]
se <- load.data(dir)
```

# Deconvolution

## Quality control

```{r}
cd <- assay(se, "counts")

# Filter out poor pixels and genes
counts <- cleanCounts(cd, min.lib.size = 100, min.reads = 10, verbose = TRUE)
dim(counts)
dim(pos)

# Log transform

```

## STDeconvolve

```{r}
# Select features
corpus <- restrictCorpus(counts, 
                         removeAbove=0.95, 
                         removeBelow = 0.05, 
                         nTopOD = NA,
                         plot = FALSE,
                         alpha = 0.05) # 1e-8

ldas <- fitLDA(t(as.matrix(corpus)), Ks = 10)

```

```{r}
opt.K <- 10
# select the LDA model of interest and get the beta (cell-type transcriptional profiles) and theta (cell-type barcode proportions) matrices.
optLDA <- optimalModel(models = ldas, opt = opt.K)
results <- getBetaTheta(optLDA, perc.filt = 0.05, betaScale = 1000)
deconProp <- results$theta
deconGexp <- results$beta
```

```{r}
## visualize deconvolved cell-type proportions
vizAllTopics(deconProp, pos[rownames(deconProp),], r=55, lwd=0)	  

## interpret these cell-types based on their gene expression
topGenes(deconGexp)
## top genes based on log 2 (fold change) for each cell-type
lapply(1:opt.K, function(i) {
  head(sort(log2(deconGexp[i,]/colMeans(deconGexp[-i,])), decreasing=TRUE))
})
```

```{r}
lapply(1:opt.K, function(i) {
vizTopic(theta = deconProp, pos = pos, topic = i, plotTitle = i,
         size = 1, stroke = 0, alpha = 0.5,
         low = "white",
         high = "red")
})
```

## Annotation strategy

# Define covariate

## Proximity to a specific cell type

```{r}
# Define target cell types
topic.target <- "9"
prop.threshold <- 0.5  
weight <- NULL

pos <- spatialCoords(se)


dim(deconProp)
dim(deconGexp)

heatmap(deconGexp)
deconProp_target <- deconProp[,topic.target]
deconProp_target <- deconProp_target[deconProp_target > prop.threshold]

length(deconProp_target)
bc.target <- names(deconProp_target)
pos.target <-  pos[bc.target,]
```

```{r}

pos <- spatialCoords(se)
adjacency.matrix <- get.adjacency.matrix(pos)

```

```{r}
# build a graph
g <- graph_from_adjacency_matrix(adjacency.matrix, mode = 'undirected')
length(components(g)$membership)

bc.idxs <- seq.int(nrow(pos))

target.idxs <- which(rownames(pos) %in% rownames(pos.target))
min.dists.mat <- get.min.dists.mat(g, bc.idxs, target.idxs)
```

```{r}
length(deconProp_target)
dim(min.dists.mat)
min.dists.mat
# Calculate min dist: use graph later, not connected
spl.norm <- (min.dists.mat - min(min.dists.mat)) / (max(min.dists.mat) - min(min.dists.mat))
spl.norm.prop <- sweep(spl.norm, 2, deconProp_target, FUN="/") # divide each row by target vector
dists.min <- rowMins(spl.norm.prop)
names(dists.min) <- rownames(pos)

se$dists.min <- min.dists.mat
se
dists.min
```

```{r}
# some spots are filled out by quality control
pos <- pos[rownames(deconProp),]

as_tibble(pos) %>%
  mutate(bc = rownames(pos)) %>%
  ggplot(aes(x = x, y = y)) +
    geom_point(size = 1, color = "grey") +
    gghighlight(bc %in% rownames(pos.target)) +
    geom_point(col = "blue", size = 1) +
    labs(title = paste0("Topic - ", topic.target), x = "pxl_row_in_fullres", y = "pxl_col_in_fullres")

as_tibble(pos) %>%
  mutate(prop = deconProp[, topic.target]) %>%
  ggplot(aes(x = x, y = y)) +
    geom_point(aes(color = prop), size = 1, stroke = 0) +
    scale_color_gradient2()
```

# LEMUR

```{r}
fit <- lemur(se, design = ~ min.dist, n_embedding = 30, test_fraction = 0.5)
fit
# fit <- test_de(fit, contrast = cond())

```

# Misc

```{r}
library(igraph)

# Create a sample graph (you can replace this with your own graph)
g <- graph.ring(10)
g <- add_vertices(g, 3, color = "red")
plot(g)

# Check if vertices 1 and 2 are connected
are.connected(g, 1, 12)  # TRUE

cl <- components(g)
class(cl)

```

```{r}
# Create a simple unweighted graph
# Example edge list
edges <- data.frame(from = c(0, 1, 1, 2), to = c(1, 2, 3, 3))

# Create a graph from the edge list
graph <- graph.data.frame(edges, directed = FALSE)  # Adjust 'directed' as needed


# Specify source and target vertices
source <- 1
target <- 3

# Find the shortest path
shortest_paths <- shortest_paths(graph, from = source, to = target)
shortest_paths$vpath
# Check if a path exists
if (length(shortest_paths) > 0) {
    # Access the first shortest path (modify as needed)
    shortest_path <- shortest_paths[[1]]

    cat("Shortest path:", shortest_path)
} else {
    cat("No path exists between", source, "and", target)
}


```

```{r}
path <- "/shares/rheumatologie.usz/caroline/spatial/SHK166_RA_Knee/deconvolution/deconvolution_k10/deconvolution_topic_features_k10.csv"
deconvolution_topic_features_k10 <- read.csv(path)
head(deconvolution_topic_features_k10)
colnames(deconvolution_topic_features_k10)

path <- "/shares/rheumatologie.usz/caroline/spatial/SHK166_RA_Knee/deconvolution/deconvolution_k10/deconvolved_spots_k10.csv"
deconvolved_spots_k10 <- read.csv(path)
head(deconvolved_spots_k10)
```

```{r}
# Create a matrix (you can replace this with your own data)
my_matrix <- matrix(c(1, 2, 3, 4, 5, 6, 3, 3, -Inf), ncol = 3)

# Calculate row minimums, ignoring NA values
row_mins <- rowMins(my_matrix, na.rm = TRUE)

# Print the result
print(row_mins)

```

# Reference

-   Tutorial from Prof. Jean Fan, <https://jef.works/blog/2023/05/29/stdeconvolve-breast-cancer/>

-   STdeconvolve Vignettes, <https://www.bioconductor.org/packages/release/bioc/vignettes/STdeconvolve/inst/doc/vignette.html#spatialexperiment-inputs>
